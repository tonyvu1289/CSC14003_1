\documentclass[11pt]{scrartcl} % Font size
\input{structure.tex} % Include the file specifying the document structure and custom commands
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------
\title{	
	\normalfont\normalsize
	\textsc{VNUHCM - University of Science \\Faculty of Information Technology}\\ % Your university, school and/or department name(s)
	\vspace{25pt} % Whitespace
	\rule{\linewidth}{0.5pt}\\ % Thin top horizontal rule
	\vspace{20pt} % Whitespace
	{\huge Lab01 - Search Problem}\\ % The assignment title
	\vspace{12pt} % Whitespace
	\rule{\linewidth}{2pt}\\ % Thick bottom horizontal rule
	\vspace{12pt} % Whitespace
}

\author{\LARGE 19120212- Vũ Công Duy \\ \LARGE 19120389 - Tô Gia Thuận}
\date{\normalsize\today} % Today's date (\today) or a custom date
\begin{document}
\maketitle 
\begin{figure}[h] % [h] forces the figure to be output where it is defined in the code (it suppresses floating)
	\centering
	\includegraphics[width=0.4\columnwidth]{hcmus.png} % Example image
\end{figure}

%------------------------------------------------
\newpage
\section{Mô tả đồ án}
\subsection{Dẫn nhập}
Từ xa xưa, con người luôn muốn tìm cách tối ưu một công việc nào đó, điều đó cũng rất đúng khi áp dụng trong việc tìm kiếm đường đi. Làm thế nào để có thể lựa chọn đường đi ngắn nhất, ít vật cản nhất khi đi từ điểm A đến điểm B. Nhưng cũng có lúc cũng chỉ quan tâm đến cách để đi từ điểm A đến B sao cho chi phí thấp nhất mà không cần quan tâm đến độ dài đường đi. Từ đó những vấn đề thực tiễn đó, chúng ta đưa ra khải niệm về bài toán tìm đường đi trong một không gian ma trận MxN.
\subsection{Yêu cầu đồ án}
 Áp dụng các thuật toán tìm kiếm không có thông tin và có thông tin để tìm đường đi thoát khỏi mê cung. 
\\- Kí hiệu \textbf{Ngôi sao} trong mê cung đánh dấu điểm bắt đầu của vật thể. 
\\- Kí hiệu \textbf{X} biểu diễn các bức tường chắn của mê cung.
\\- Kí hiệu \textbf{EXIT} đánh dấu lối thoát của mê cung
\\Yêu cầu đồ án: Áp dụng 4 thuật toán DFS, BFS, GBFS, A* để tìm đường đi thoát khỏi mê cung đồng thời đi qua các các điểm thưởng.
\begin{figure}[h] % [h] forces the figure to be output where it is defined in the code (it suppresses floating)
	\centering
	\includegraphics[width=0.5\columnwidth]{demo_maze.png} % Example image
\end{figure}

\section{Xây dựng cấu trúc chương trình} \cite{standfordcs221}
Mục tiêu của việc xây dựng cấu trúc chương trình là để việc cài đặt những thuật toán được tổng quát hóa, giúp cài đặt những bài toán khác nhau và giải chúng bằng nhiều thuật toán khác nhau trở nên đơn giản hơn. 

Theo cách những nhà phát triển phần mềm, mã nguồn có thể được tái sử dụng trong nhiều trường hợp khác nhau, giúp người lập trình có thể tập trung hơn vào phần tối ưu thuật toán mà không nghĩ ngợi nhiều về phần kỹ thuật, cài đặt.

Việc cài đặt dựa chủ yếu vào kỹ thuật kế thừa, đa hình trong kỹ thuật lập trình hướng đối tượng. Chương trình sẽ được trực quan hóa bằng biểu đồ UML sau đây.

\newpage
\begin{figure}[h] % [h] forces the figure to be output where it is defined in the code (it suppresses floating)
	\centering
	\includegraphics[width=1.2\columnwidth]{classes_uml_diagram.png} % Example image
\end{figure}

\subsection{Hai class trừu tượng (Abstract Class)}
Ở level cao nhất chính là 2 class : Solutimethodon và SearchProblem tương ứng với hai thực thể (entity) là lời giải và bài toán.

Ở abstract class, phương thức (method) sẽ được cài đặt dưới dạng phương thức ảo (virtual method), những phương thức này sẽ được các lớp con kế thừa và được cài đặt trong quá trình viết các lớp con ấy.

Để tránh trường hợp method của abstract class được gọi (có thể do method của class kế thừa chưa được cài đặt), ta sẽ thêm dòng báo lỗi khi method của abstract class được gọi raise NotImplementedError(...)

%------------------------------------------------
\lstinputlisting[
	caption=Cài đặt abstract class, % Caption above the listing
	label=lst:luftballons, % Label for referencing this listing
	language=Perl, % Use Perl functions/syntax highlighting
	frame=single, % Frame around the code listing
	showstringspaces=false, % Don't put marks in string spaces
	numbers=left, % Line numbers on left
	numberstyle=\tiny, % Line numbers styling
	]{abstract_class.txt}

Cấu trúc của bài toán cũng như những "nguyên liệu" để giải bài toán ấy như : trạng thái ban đầu(init state), trạng thái đích(goals), mở rộng trạng thái kề(expand successor)\cite{csttnt_lhb},... được biểu diễn dưới dạng các phương thức của một thực thể của class SearchProblem. Ở class Solution, phương thức duy nhất là solve(problem,display) sẽ được truyền vào tham số là một thực thể của class SearchProblem. Phương thức solve sẽ được cài đặt một cách trừu tượng để có thể giải được bất cứ bài toán tìm kiếm nào dựa vào những "nguyên liệu" được lấy từ thực thể class SearchProblem truyền vào.

Phương thức display\_explored(state) của class SearchProblem có nhiệm vụ trực quan hóa trạng thái hiện tại để quá trình cài đặt thuật toán thuận lợi hơn, không bắt buộc có.Vì vậy, class kế thừa SeachProblem không bắt buộc cài đặt phương thức này, ta cho lệnh "pass" (bỏ qua) nếu phương thức này được gọi từ abstract class.

\subsection{Class PriorityQueue}
Đây là lớp hàng đợi ưu tiên được bổ sung một vài tính năng để tối ưu cho bài toán tìm kiếm.

Các tính năng bổ sung bao gồm : không push lại những phần tử đã được pop, update chỉ số ưu tiên nếu chỉ số ưu tiên mới lớn hơn chỉ số cũ. 
\lstinputlisting[
	caption=Cài đặt class PriorityQueue, % Caption above the listing
	label=lst:luftballons, % Label for referencing this listing
	language=Perl, % Use Perl functions/syntax highlighting
	frame=single, % Frame around the code listing
	showstringspaces=false, % Don't put marks in string spaces
	numbers=left, % Line numbers on left
	numberstyle=\tiny, % Line numbers styling
]{priority_queue.txt}

Thuộc tính \textbf{heap} là một list các tuple (element, value).Việc sắp xếp, pop, push các phần tử theo cấu trúc heap được thực hiện bởi hàm heappush trong thư viện heapq của python3.

Thuộc tính \textbf{priority} là một dict lưu trữ các element đã được thêm vào heap (kể cả các element đã được pop khỏi heap) và value của mỗi element đó. Những element nào đã được pop ra sẽ được gán value bằng với thuộc tính \textbf{DONE} mang giá trị $- \infty$ để phân biệt với các giá trị khác, thuận tiện cho việc viết điều kiện rẽ nhánh cho chương trình bỏ qua update hoặc thêm vào heap nếu đã được pop.
\subsection{Các class kế thừa abstract class}
Phần này sẽ giải thích các class kế thừa abstract tức những thuật toán cụ thể
\subsubsection{BreadFirstSearch}
Đầu tiên ta khởi tạo những biến sau đây:  

- totalCost : lưu trữ tổng chi phí đường đi  

- toltaExpand : lưu trữ tổng số node mở rộng  

- action : dãy các action thực hiện để biến initState thành goalState  

- backPointer : là hashtable với key là trạng thái và value là các cặp (state,backPointer) với backPointer là trạng thái phía trước.  

- frontier : là một hàng đợi. Sẽ lưu các cặp (state,cost) sẽ được visit.  

Ta sẽ khởi tạo frontier chứa initState. Các biến khác khởi tạo bằng 0 hoặc rỗng.  

Quy trình thực hiện thuật toán được thực hiện như sau:
- Dequeue frontier, sẽ được một cặp state và chi phí để đi đến state đó.

- Tăng totalExpand lên 1 đơn vị.  

- Kiểm tra trạng thái vừa pop ra có phải là trạng thái đích chưa. Nếu đúng thì dựa vào backPointer và cost để hoàn thành list action và thoát khỏi hàm.  

- Nếu chạy hàm expand() để lấy những successor và chi phí cần thêm để đi tới chúng. Nếu successor đó có trong backPointer thì bỏ qua.

- enqueue những trạng thái mới và cost của chúng.

- Cập nhật backPointer của từng trạng thái mới chính là trạng thái vừa pop ở trên.

- Lặp đến khi nào frontier hết phân tử.

\subsubsection{DepthFirstSearch}

Thực hiện giống BFS nhưng code{frontier} là một stack thay vì queue. Hàm dequeue và enequeue thay thế bằng hàm pop và push.

\subsubsection{A*}
Khởi tạo thêm hashtable cost với key là trạng thái, value là chi phí để đi đến trạng thái đó từ trạng thái ban đầu.

Thực hiện giống BFS nhưng code{frontier} là một priorityqueue(class đã được giải thích ở trên) thay vì queue. Hàm dequeue và enequeue thay thế bằng hàm add\_update và pop\_delete.

Phần addupdate element : thay vì add (state,cost), ta add (state,cost + h(x)).

Thay vì dựa vào backPointer để loại successor, ta dựa vào hashtable cost.

Ngoài ra, khi add\_update element thành công thì mới bổ sung hastable cost và backPointer.



\subsubsection{BestFirstSearch}
Thực hiện giống A*.

Phần add\_update element : thay vì add (state,cost + h(x)), ta add (state,h(x)).

\section{Cơ sở lý thuyết}
\subsection{Không gian trạng thái}
Xét mê cung trong bài toán nằm trên một hệ trục tọa độ hai chiều Oxy. Gọi \textbf{x} và \textbf{y} lần lượt là hoành độ và tung độ của tác nhân.\\
- Trạng thái của tác nhân: Tọa độ (x,y) trên ma trận.\\
- Trạng thái bắt đầu (start state): Tọa đô ($x^{'}$,$y^{'}$) của kí hiệu \textbf{Ngôi sao} trên ma trận.\\
- Trạng thái kết thúc (goal state): Tọa độ ($x^{''}$,$y^{''}$) của kí hiệu \textbf{EXIT} trên ma trận.\\
- Hành động của tác nhân: Di chuyển lên trên, xuống dưới, qua trái, qua phải.\\
- Hàm kế nhiệm, kế thừa (successor function): ExpandSuccessor - dùng để lựa chọn ô kế nhiệm ô cũ và cập nhật lại vị trí hiện tại của tác nhân.\\
- Hàm kiểm tra kết thúc: isGoal - kiểm tra trạng thái tác nhân đang xét (x,y) có phải là ô kết thúc (lối ra của mê cung) hay không.
\subsection{Xây dựng cấu trúc bài toán}
Để cái đặt các thuật toán tìm kiếm trên ma trận có kích thước MxN, ta cần xây dựng một danh sách các điểm kề với điểm tại vị trí đang xét và chi phí phát sinh giữa điểm đang xét và các cạnh kề của nó.\\

Gọi ô (vị trí) của tác nhân tại một điểm nhất định là (x,y) trong ma trận, ứng với các hướng di chuyển lên, xuống, trái, phải, ta sẽ có các ô kề với tọa độ lần lượt là (x,y-1), (x,y+1), (x-1,y), (x+1,y). Do các ô có kích thước là như nhau nên chi phí di chuyển tới các ô kề sẽ là như nhau và trong đồ án này sẽ được đặt mặc định là 1.\\

Bằng cách phát sinh các ô kề của ô mà tác nhân đang đứng, ta sẽ có thể xây dựng danh sách các ô kề và chi phí. Khi cần lấy danh sách các ô kề và chi phí của ô hiện tại mà tác nhân đang đứng (x,y), ta phát sinh ra tọa độ ô kề thứ i của u bằng công thức (x+$dx_{i}$, y+$dy_{i}$) và chi phí tương ứng là $w_{i}$ , $\forall{i\ge0}\cup{i\le4}$\\

Sau khi khởi tạo được danh sách các ô kề của ô mà tác nhân đang đứng, ta sẽ cài đặt hàm kế nhiệm để tính toán xem các ô kề có phải là bức tường chắn hay không đồng thời tính toán chi phí, và dựa trên kết quả đó để trả về những ô phù hợp có thể kế nhiệm ô hiện tại.

\newpage
\section{Đánh giá thực nghiệm}
\subsection{Giao diện kết quả}
	\begin{figure}[h] % [h] forces the figure to be output where it is defined in the code (it suppresses floating)
		\centering
		\includegraphics[width=0.8\columnwidth]{Figures/fg1_dfs.png} % Example image
	\end{figure}
\begin{itemize}
	\item DFSSolution: Tên thuật toán sử dụng (bao gồm DFSSolution, BFSSolution, GreedyBestFirstSearchSolution, A\_StarSolution) \\
	\item \textbf{$\triangle$}: Đường đi của tác nhân thoát khỏi mê cung. \\
	\item \textbf{$\bigcirc$}: Các ô đã duyệt qua (bao gồm cả ô được chọn làm đường đi và ô không được chọn làm đường đi).\\
	\item \textcolor{yellow}{\textbf{$\star$}}: Đánh dấu điểm bắt đầu của tác nhân. \\
	\item \textbf{X}: biểu diễn các bức tường chắn của mê cung.\\
	\item \textcolor{red}{EXIT} đánh dấu lối thoát của mê cung.\
\end{itemize}

\newpage
\subsection{Bản đồ không có điểm thưởng}
\begin{itemize}
	\item Bản đồ 1:
		\begin{figure}[h] \label{123}
			\centering
			\begin{tabular}{cc}
				\includegraphics[width=8cm]{Figures/fg1_dfs.png} &
				\includegraphics[width=8cm]{Figures/fg1_bfs.png} \\
			\end{tabular}
		\end{figure}
		\begin{figure}[h] \label{fig:three-alternative-operations}
			\centering
			\begin{tabular}{cc}
				\includegraphics[width=8cm]{Figures/fg1_gbfs.png} &
				\includegraphics[width=8cm]{Figures/fg1_astar.png}
			\end{tabular}
		\end{figure}
		\begin{itemize}
			\item \textbf{Nhận xét}: Thuật toán DFS duyệt qua các điểm rất ít mà vẫn có thể tìm được đường để thoát ra khỏi mê cung, tuy nhiên đường đi tìm được không tối ưu (tìm được đường đi dài nhất trong 4 thuật toán). Thuật toán DFS có vẻ khác biệt rất lớn với 3 thuật toán còn lại khi số ô duyệt qua là ít nhất và tìm được đường đi dài nhất. Cả 3 thuật toán BFS,GBFS, Astar hầu như phải duyệt qua hết tất cả các ô. Trong bản đồ này thì 3 thuật toán này cho ra kết quả khá giống nhau.
		\end{itemize}
	
	\newpage
	\item Bản đồ 2:
	\begin{figure}[h] \label{bd2}
		\centering
		\begin{tabular}{cc}
			\includegraphics[width=8cm]{Figures/fg2_dfs.png} &
			\includegraphics[width=8cm]{Figures/fg2_bfs.png} \\
		\end{tabular}
	\end{figure}
	\begin{figure}[h] \label{Hình 2}
		\centering
		\begin{tabular}{cc}
			\includegraphics[width=8cm]{Figures/fg2_gbfs.png} &
			\includegraphics[width=8cm]{Figures/fg2_astar.png}
		\end{tabular}
	\end{figure}
	\begin{itemize}
		\item \textbf{Nhận xét}: Trong bản đồ này, ta dễ dàng nhận thấy thuật toán DFS duyệt qua ít ô nhất nhưng lại tìm được đường đi dài nhất. Ba thuật toán BFS, GBFS, Astar tìm được những đường đi khác nhau nhưng thuật toán BFS và Astar lại ra đường đi bằng nhau và ngắn nhất. Thuật toán GBFS lại cho ra kết quả độ dài đường đi tương đương với DFS, bởi vì thuật toán GBFS sử dụng hàm heuristic để đánh giá ước lượng để chọn đường đi, tuy nhiên do có những vật cản. Theo lý thuyết ô đó rất gần lối thoát (dựa trên khoảng cách Manhattan) nhưng thực tế do có vật cản làm cho đường đi không còn được tối ưu nữa. Thuật toán Astar về lý thuyết cũng sử dụng hàm heuristic (khoảng cách Manhattan) nhưng đây là thuật toán dựa trên sự kết hợp từ thuật toán Dijkstra nên sẽ tính toán để tối ưu chi phí hơn từ đó vừa tìm được đường đi ngắn vừa tối ưu được chi phí kể cả khi có vật cản.
	\end{itemize}
\end{itemize}



\bibliographystyle{plain}
\bibliography{ref}
\end{document}
